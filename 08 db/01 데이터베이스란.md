## 영속성 (Persistence)
- 인 메모리 (In-memory) 방식: RAM은 매우 빠르지만, 휘발성
- **영속성(Persistence)**
  - 데이터 베이스의 특징
  - 어플리케이션이 종료된 후에도 데이터가 보존
  - 영속성이 없는 데이터는 인 메모리에만 존재하며, 프로그램이 종료되면 데이터 사라짐
<br/>

## 데이터베이스
- 데이터의 집합
- 실제 데이터가 저장되는 저장소의 역할
- **DBMS (Database Management System)**
  - 데이터베이스를 실제로 운영하고, 체계적으로 관리하는 소프트웨어
  - 사용자와 데이터베이스를 연결시켜주는 소프트웨어 
  - '데이터베이스에 저장한다' === DBMS가 설치된 서버에 데이터를 저장 
  - DBMS가 설치된 서버 컴퓨터가 **데이터베이스 서버 (DB 서버)**
- 키 (key)
  - 데이터베이스에서 튜플을 식별하거나 순서대로 정렬할 때 구분하고 정렬의 기준이 되는 속성
  - 기본키 (PK, Primary Key)
    - 특정 튜플 (행)을 유일하게 구별할 수 있는 속성
    - **NULL값 불가, 중복 값 불가**
  - 외래키 (FK, Foreign Key): 어떤 테이블의 기본키를 참조하는 속성 
<br/>

## 데이터베이스의 종류
### 관계형 데이터베이스 (RDB - Relational Database)
- **데이터의 형식이 정해져 있고**, 데이터 간의 **관계**를 맺어 모순이 없는 데이터를 유지할 수 있도록 도와주는 데이터베이스
- **테이블**의 표 형태로 데이터를 저장
  - 테이블은 행(Row)과 열(Column)로 구성
  - 열은 미리 정해진 데이터 타입을 가짐
- 정확하고 일관된 데이터가 중요한 경우에 주로 사용 (e.g. 은행, 회계 시스템)
- **'모순이 없는 데이터' === 데이터의 무결성 (Integrity)과 정합성 (Consistency)가 높음**
  - 무결성: 데이터에 오류가 없음
  - 정합성: 데이터가 항상 올바르고 일관된 상태를 유지함
#### MySQL
##### 장점
- 압도적인 많은 인지도와 사용처
- 뛰어난 안정성과 신뢰성 (데이터의 무결성과 정합성을 중요하게 다룸)
- 높은 성능 (다양한 쿼리 최적화 기법 & 인덱싱 (indexing) 기능을 통해)
- 쉬운 학습과 풍부한 자료 
- 강력한 보안 기능
##### 적합한 사용 상황
- 데이터의 무결성과 일관성이 매우 중요할 때 (e.g. 돈이나 숫자에 관련된 데이터, ...)
- 데이터 간의 관계가 복잡하고 명확할 때
- 데이터의 스키마(구조)가 비교적 고정적이고 변경이 적을 때
- 복잡한 쿼리(JOIN, 집계, 통계 등)가 자주 필요할 때
- 검증되고 안정적인 솔루션을 선호할 때
### 비관계형 데이터베이스 (NoSQL - Non-relational Database)
- **데이터의 형식이 고정되어 있지 않고, 매우 유연하게 확장**할 수 있는 데이터베이스
- 문서(Document), 키-값(Key-Value) 등 다양한 형태로 데이터를 저장
- 다양한 형식의 데이터를 빠르게 저장하고 검색해야 하는 경우에 주로 사용 (e.g. SNS 서비스, 빅데이터)
- 저장되는 데이터를 제대로 관리하지 않으면 데이터베이스에 저장된 데이터를 신뢰할 수 없게 될 수도 있음 
#### 비관계형 데이터베이스 종류
##### 키-값 데이터베이스 (Key-Value Stores)
- 가장 단순한 형태의 NoSQL 데이터베이스
- 데이터를 고유한 "키(Key)"와 해당 키에 연결된 "값(Value)" 쌍으로 저장
- 값은 문자열, JSON, 이미지 등 어떤 형태도 가능
- 특징: 빠른 읽기/쓰기
- 주로 캐싱, 세션 관리 등에 사용
- 대표적인 db: Redis, Memcached, DynamoDB (AWS)
- 예시: `user:123 -> { "name": "Alice", "age": 30 }`
##### 문서 지향 데이터베이스 (Document Databases)
- 데이터를 문서 형태로 저장
- 문서는 JSON, BSON, XML등 자기 기술적인 형식으로 보통 저장됨
- 유연한 스키마 ➡️ 자유로운 필드(속성)의 추가/삭제
- 각 문서가 독립적인 스키마를 가질 수 있음
- 대표적인 db: MongoDB, Couchbase, RavenDB
- 예시
```javascript
// 상품 문서 1
{
  "product_id": "P001",
  "name": "노트북",
  "price": 1200000,
  "category": "전자기기"
}

// 상품 문서 2 (새로운 필드 추가 가능)
{
  "product_id": "P002",
  "name": "블루투스 이어폰",
  "price": 150000,
  "category": "전자기기",
  "color_options": ["black", "white", "blue"]
}
```
##### 컬럼 지향 데이터베이스 (Column-Family Stores)
- 데이터를 행(Row)과 열(Column)로 구성
- RDB와 다른 점: 열 그룹(컬럼 패밀리) 단위로 데이터를 저장하고 관리
- 대규모 분산 환경에서 뛰어난 확장성과 고가용성을 제공
- 매우 많은 양의 데이터를 효율적으로 저장하고 검색하는 데 사용
- 대표적인 db: Apache Cassandra, HBase, Google Bigtable
- 예시: 사용자 프로필 데이터에서 기본 정보 컬럼 패밀리와 활동 정보 컬럼 패밀리를 따로 저장하여 효율적으로 접근
##### 그래프 데이터베이스 (Graph Databases)
- 데이터를 노드(Node), 엣지(Edge - 관계), 속성(Property)으로 표현하여 저장
- 데이터 간의 복잡한 관계를 모델링하고 탐색하는 데 매우 강력
- 소셜 네트워크, 추천 시스템, 사기 탐지 등에 주로 사용
- 대표적인 db: Neo4j, Amazon Neptune, ArangoDB
- 예시: "사람(노드)이 친구(엣지)에게 영화(노드)를 추천(엣지)한다"
##### 시계열 데이터베이스 (Time Series Databases - TSDB)
- 시간 순서에 따라 발생하는 데이터를 효율적으로 저장하고 검색하는 데 특화
- 시간이 지남에 따라 연속적으로 발생하는 데이터를 다루는 데 최적화
- 대표적인 db: InfluxDB, Prometheus, TimescaleDB
#### 비관계형 데이터베이스 등장 계기
##### 폭발적인 데이터 증가
- 기존 RDBMS는 대규모 데이터를 처리하고 저장하는 데 비용과 효율성 측면에서 비효율적
##### 데이터 다양성 증가 (비정형 데이터의 등장)
- 이미지, 동영상, 로그 데이터, 소셜 미디어 게시물, 센서 데이터 등 다양한 형태의 비정형(Unstructured) 및 반정형(Semi-structured) 데이터의 등장 
- RDBMS의 고정된 스키마 ➡️ 유연하고 다양한 형태의 데이터를 저장하고 관리하기에 부적합
##### 확장성의 요구 (수평적 확장의 필요성)
- 확장성 (Scalability): 시스템이 더 많은 부하나 사용자 요청을 잘 처리할 수 있도록 성능을 키우는 능력
- RDBMS
  - 수직적 확장 (Vertical Scaling)에 강함
  - 한 서버에 CPU, RAM을 업그레이드하여 성능을 높이는 방식
  - 장점: 기존 구조를 바꿀 필요가 없음 
  - 한계: 많은 비용, 성능 향상에 한계, 장애 시 전체 서비스가 멈출 위험 
- No-SQL
  - 처음부터 수평적 확장(Horizontal Scaling)을 염두에 두고 설계
  - 여러 대의 저렴한 서버를 추가하여 전체 시스템의 용량과 성능을 늘리는 방식
  - 장점: 비용 효율적, 시스템이 커질수록 성능을 거의 선형적으로 늘릴 수 있음, 장애가 나도 일부 서버만 영향을 받음
  - 한계: 데이터 일관성 유지가 어렵고, 복잡한 쿼리 (JOIN 등)에 약함, 구조 설계와 운영이 조금 더 복잡할 수 있음
- 웹 서비스가 커질수록, 갑자기 많은 트래픽과 데이터를 처리해야 하므로,
이런 상황에서 더 유연하고 저렴하게 확장할 수 있는 NoSQL의 수평적 확장 능력이 매우 중요
##### 개발 생산성 및 유연한 스키마
- 애자일(Agile) 개발 방식의 확산 ➡️ 빠르게 기능을 개발하고 배포하는 것이 중요
- RDBMS의 엄격한 스키마 구조 ➡️ 데이터 모델을 변경할 때마다 복잡한 작업을 요구
- No-SQL은 대부분 스키마리스 (Schema-less) 또는 유연한 스키마 ➡️ 데이터 모델의 변경이 자유롭고 개발 주기를 단축하는 데 기여
- 빠르게 변화하는 비즈니스 요구사항에 유연하게 대응 가능
##### 특정 워크로드에 최적화된 성능
- No-SQL: 특정 데이터 모델과 워크로드에 최적화되어 설계
- "특정 상황에 매우 뛰어난" 여러 데이터베이스를 혼합하여 사용하는 것이 더 효율적이라는 인식이 확산