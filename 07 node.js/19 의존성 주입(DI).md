## 의존관계 (Dependency)

- "A가 B를 의존한다.": B의 기능이 추가 또는 변경되거나 형식이 바뀌면 그 영향이 A에 미침

  <br/>

## 의존성 주입 (Dependency Injection)

### 의존성 주입 전

```ts
// 햄버거 레시피
class HamburgerRecipe {
  getRecipe() {
    return "햄버거 만들기 레시피";
  }
}

// 버거 셰프 (직접 의존성 생성)
class BurgerChef {
  private recipe: HamburgerRecipe;

  constructor() {
    // 클래스 내부에서 의존성을 직접 생성 → 강한 결합
    this.recipe = new HamburgerRecipe();
  }

  cook() {
    console.log(this.recipe.getRecipe());
  }
}

// 실행
const chef = new BurgerChef();
chef.cook();
```

- `BurgerChef`가 `HamburgerRecipe`에 강하게 결합
- 다른 레시피(e.g.`CheeseBurgerRecipe`)로 바꾸려면 `BurgerChef` 내부 코드를 수정해야 함
- 테스트 코드 작성이 어려움

### 의존성 주입 후

- 하나의 객체가 다른 객체에 의존성을 제공
- 생성자를 통해 클래스와 함수의 의존성을 주입
  - 의존성: 함수, 클래스 등이 내부에서 다른 함수, 클래스를 사용
  - 주입: 함수, 클래스 등이 내부에서 사용하는 다른 함수, 클래스를 외부에서 생성하여 주입
- 의존관계를 외부에서 결정 ➡️ 클래스 변수를 결정하는 방법들이 곧 DI를 구현하는 방법
- 런타임 시점의 의존관계를 외부에서 주입하여 DI 구현이 완성

```ts
// 레시피 인터페이스 (공통 계약)
interface BurgerRecipe {
  getRecipe(): string;
}

class HamburgerRecipe implements BurgerRecipe {
  getRecipe() {
    return "햄버거 만들기 레시피";
  }
}

class CheeseBurgerRecipe implements BurgerRecipe {
  getRecipe() {
    return "치즈버거 만들기 레시피";
  }
}

// 버거 셰프 (의존성을 외부에서 주입)
class BurgerChef {
  constructor(private recipe: BurgerRecipe) {} // 인터페이스 타입으로 의존

  cook() {
    console.log(this.recipe.getRecipe());
  }
}

// 실행: 의존성을 외부에서 주입
const chef1 = new BurgerChef(new HamburgerRecipe());
chef1.cook(); // 햄버거 만들기 레시피

const chef2 = new BurgerChef(new CheeseBurgerRecipe());
chef2.cook(); // 치즈버거 만들기 레시피
```

- 의존성 교체가 쉬움: `BurgerChef` 수정 없이 다른 레시피로 변경 가능
- 테스트 용이
- 유지보수성 향상 ➡️ 클래스 간 결합도 감소

### 장점

#### 결합도 감소

```ts
// 👎 UserService가 UserRepostiroy의 구체 클래스에 의존
// 다른 저장소로 교체하려면 코드 수정이 필요
class UserService {
  private repo: UserRepository;
  constructor() {
    this.repo = new UserRepository();
  }
}
```

```ts
// 👍 UserService는 인터페이스에만 의존하고, 구체 구현은 외부에서 주입
// 특정 구현을 바꾸더라도 UserService는 건드릴 필요가 없음
class UserService {
  constructor(private repo: UserRepository) {}
}
```

- 특정 모듈 변경 시 다른 모듈에 미치는 영향이 줄어듦
- 확장 (새 구현체 추가) 시 기존 코드 수정을 최소화

#### 테스트 용이성 확장

```ts
const mockRepo: UserRepository = {
  findUser: async () => ({ id: 1, name: "test" }),
};

const service = new UserService(mockRepo);
```

- 실제 DB 없이도 단위 테스트 가능
- 테스트 속도와 안정성이 크게 올라감

#### 유지보수성 및 확장성 증가

- 기존 구현을 변경하지 않고도 새로운 구현체를 쉽게 주입 가능
- e.g. 개발 환경 → `InMemoryRepository` / 운영 환경 → `MySQLRepository`

#### SRP (단일 책임 원칙) 강화

- 객체는 자신의 로직만 관리하고, 어떤 의존성을 쓸지 결정하는 책임은 외부(조립자, IoC 컨테이너)가 맡음
- 클래스 내부에서 의존성 생성 코드를 제거하므로, 로직이 깔끔

#### IoC (Inversion of Control) 구현

- 객체가 스스로 의존성을 만들지 않고, 외부에서 주입받음 → 제어의 흐름이 역전됨
- 결과적으로 객체의 생성과 사용이 분리되어, 구성(Composition)이 훨씬 유연해짐

#### 테스트 맻 배포 환경 분리 용이

- 로컬 개발, 테스트, 운영 환경에 맞춰 다른 구현체를 주입 가능

#### 확장 시 코드 수정 최소화

- 전략 패턴, 어댑터 패턴 같은 구조와 궁합이 좋음

- 예: PaymentService가 KakaoPay를 쓰다가 PayPal로 변경되어도, 생성부만 바꾸면 됨
