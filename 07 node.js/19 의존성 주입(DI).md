## 의존관계 (Dependency)

- "A가 B를 의존한다.": B의 기능이 추가 또는 변경되거나 형식이 바뀌면 그 영향이 A에 미침

  <br/>

## 의존성 주입 (Dependency Injection)

### 의존성 주입 전

```ts
// 햄버거 레시피
class HamburgerRecipe {
  getRecipe() {
    return "햄버거 만들기 레시피";
  }
}

// 버거 셰프 (직접 의존성 생성)
class BurgerChef {
  private recipe: HamburgerRecipe;

  constructor() {
    // 클래스 내부에서 의존성을 직접 생성 → 강한 결합
    this.recipe = new HamburgerRecipe();
  }

  cook() {
    console.log(this.recipe.getRecipe());
  }
}

// 실행
const chef = new BurgerChef();
chef.cook();
```

- `BurgerChef`가 `HamburgerRecipe`에 강하게 결합
- 다른 레시피(e.g.`CheeseBurgerRecipe`)로 바꾸려면 `BurgerChef` 내부 코드를 수정해야 함
- 테스트 코드 작성이 어려움

### 의존성 주입 후

- 하나의 객체가 다른 객체에 의존성을 제공
- 생성자를 통해 클래스와 함수의 의존성을 주입
  - 의존성: 함수, 클래스 등이 내부에서 다른 함수, 클래스를 사용
  - 주입: 함수, 클래스 등이 내부에서 사용하는 다른 함수, 클래스를 외부에서 생성하여 주입
- 의존관계를 외부에서 결정 ➡️ 클래스 변수를 결정하는 방법들이 곧 DI를 구현하는 방법
- 런타임 시점의 의존관계를 외부에서 주입하여 DI 구현이 완성
- 장점
  - 모듈 안에서 클래스를 불러오거나 새로 생성하는 것을 피함
  - 객체 지향적 아키텍처 설계 ➡️ 유지 보수성 향상

```ts
// 레시피 인터페이스 (공통 계약)
interface BurgerRecipe {
  getRecipe(): string;
}

class HamburgerRecipe implements BurgerRecipe {
  getRecipe() {
    return "햄버거 만들기 레시피";
  }
}

class CheeseBurgerRecipe implements BurgerRecipe {
  getRecipe() {
    return "치즈버거 만들기 레시피";
  }
}

// 버거 셰프 (의존성을 외부에서 주입)
class BurgerChef {
  constructor(private recipe: BurgerRecipe) {} // 인터페이스 타입으로 의존

  cook() {
    console.log(this.recipe.getRecipe());
  }
}

// 실행: 의존성을 외부에서 주입
const chef1 = new BurgerChef(new HamburgerRecipe());
chef1.cook(); // 햄버거 만들기 레시피

const chef2 = new BurgerChef(new CheeseBurgerRecipe());
chef2.cook(); // 치즈버거 만들기 레시피
```

- 의존성 교체가 쉬움: `BurgerChef` 수정 없이 다른 레시피로 변경 가능
- 테스트 용이
- 유지보수성 향상 ➡️ 클래스 간 결합도 감소
